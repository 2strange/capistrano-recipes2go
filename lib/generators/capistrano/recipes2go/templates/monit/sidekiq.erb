# Monit configuration for SIDEKIQ-six :  <%= fetch(:application) %>  (<%= fetch(:stage) %>)
<% for_each_process do |service_file, idx| %>

CHECK process <%= sidekiq_service_name(service_file) %> with pidfile <%= fetch(:monit_sidekiq_pid_path) %>/<%= service_file %>.pid

  <% if fetch(:sidekiq_ruby_vm) == :rvm %>
  start program = "/bin/bash -lc '<%= rvm_command(fetch(:sidekiq_user)) %> bundle exec sidekiq <%= @side_kiq_args %>'" with timeout <%= fetch(:monit_sidekiq_timeout_sec, 90) %> seconds  # for rvm
  stop program = "/bin/bash -lc '<%= rvm_command(fetch(:sidekiq_user)) %> bundle exec sidekiqctl stop <%= fetch(:monit_sidekiq_pid_path) %>/<%= service_file %>.pid'" with timeout <%= fetch(:monit_sidekiq_timeout_sec, 90) %> seconds  # for rvm
  <% else %>
  start program = "/usr/local/bin/bundle exec sidekiq <%= @side_kiq_args %>" with timeout <%= fetch(:monit_sidekiq_timeout_sec, 90) %> seconds
  stop program = "/usr/local/bin/bundle exec sidekiqctl stop <%= fetch(:monit_sidekiq_pid_path) %>/<%= service_file %>.pid" with timeout <%= fetch(:monit_sidekiq_timeout_sec, 90) %> seconds
  <% end %>

  GROUP sidekiq-<%= fetch(:sidekiq_monit_group, fetch(:application)) %>-<%= fetch(:stage) %>
	GROUP sidekiq
  # if does not exist then start # (default)
  if totalmem > <%= ( fetch( :monit_sidekiq_totalmem_mb, 300 ).to_i * 0.75 ).to_i %> MB then <%= monit_alert %>
  if totalmem > <%= fetch( :monit_sidekiq_totalmem_mb, 300 ) %> MB for 3 cycles then restart
  # if does not exist for 3 cycles then <%= monit_alert %>
  # alert <%= fetch(:monit_mail_to) %> only on { pid }
  if 3 restarts within 5 cycles then <%= monit_alert %>
  if 3 restarts within 5 cycles then timeout
  if 2 restarts within 3 cycles then <%= monit_alert %>
  if changed pid 2 times within 10 cycles then <%= monit_alert %>

<% end %>